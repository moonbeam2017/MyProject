# 基础导论

## 软件过程模型

### 瀑布模型

瀑布模型是将软件生存周期中的各个活动规定为依线性连接的若干阶段的模型，包括需求分析、设计、编码、测试、运行与维护。由前至后、相互衔接的固定次序，如同瀑布流水逐级下落。
- 缺图
  
特征：

接受上一阶段的结果作为本阶段的输入，利用这一输入实施本阶段应完成的活动对本阶段的工作进行评审，将本阶段的结果作为输出，传递给下一阶段。

缺点：

缺乏灵活性，难以适应需求不明确或需求经常变化的软件开发；开发早期存在的问题往往要到交付使用时才发现，维护代价大。
- 阶段间具有顺序性和依赖性。
- 推迟实现的观点。
- 每个阶段必须完成规定的文档;每个阶段结束前完成文档审查。

### 增量模型

又称演化模型，是一种渐进地开发逐渐完善的软件版本的模型。在使用增量模型时，第一个增量往往是实现基本需求的核心产品。核心产品交付用户使用后，经过评价形成下一个增量的开发计划，它包括对核心产品的修改和一些新功能的发布。这个过程在每个增量发布后不断重复，直到产生最终的完善产品。

- 缺图

特征：

- 反复的应用瀑布模型的基本成分和演化模型的迭代特征，每一个线型过程产生一个“增量”的发布或提交，该增量均是一个可运行的产品。
- 早期的版本实现用户的基本需求，并提供给用户评估的平台。

优点：

- 在较短时间内向用户提交可完成部分工作的产品，并分批、逐步地向用户提交产品。从第一个构件交付之日起，用户就能做一些有用的工作。
- 整个软件产品被分解成许多个增量构件，开发人员可以一个构件一个构件地逐步开发。
- 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。
- 采用增量模型比采用瀑布模型和快速原型模型需要更精心的设计，但在设计阶段多付出的劳动将在维护阶段获得回报。

增量模型的缺点：

- 在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。此外，必须把软件的体系结构设计得便于按这种方式进行扩充，向现有产品中加入新构件的过程必须简单、方便，也就是说，软件体系结构必须是开放的。
- 多个构件并行开发，具有无法集成的风险。
- 容易退化为边做边改模型，从而使软件过程的控制失去整体性

### 螺旋模型

螺旋模型将瀑布模型和增量模型结合起来，加入了风险分析。在该模型中，软件开发是一系列的增量发布，早期的迭代中，发布的增量可能是一个纸上的模型或原型，在以后的迭代中，逐步产生系统更加完善的版本。螺旋模型的基本思想是降低风险。

特征：

风险驱动，需要相当丰富的风险评估经验和专门知识，否则风险更大；主要适用于内部开发的大规模软件项目，随着过程的进展演化，开发者和用户能够更好的识别和对待每一个演化级别上的风险；随着迭代次数的增加，工作量加大，软件开发成本增加。
四个象限代表了以下活动：
- 制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；
- 风险分析：分析评估所选方案，考虑如何识别和消除风险；
- 实施工程：实施软件开发和验证；
- 客户评估：评价开发工作，提出修正建议，制定下一步计划。

优点：

- 设计上的灵活性,可以在项目的各个阶段进行变更.
- 以小的分段来构建大型系统,使成本计算变得简单容易
- 客户始终参为保证了项目不偏离正确方向以及项目的可控性
- 客户始终掌握项目的最新信息,从而他或她能够和管理层有效地交互.
- 客户认可这种公司内部的开发方式带来的良好的沟通和高质量的产品.

缺点：
- 很难让用户确信这种演化方法的结果是可以控制的。建设周期长,而软件技术发展比较快,所以经常出现软件开发完毕后,和当前的技术水平有了较大的差距,无法满足当前用户需求.

### 喷泉模型

喷泉模型是一种以用户需求为动力，以对象作为驱动的模型，适合于面向对象的开发方法。它克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。喷泉模型使开发过程具有迭代性和无间隙性。

优点：

喷泉模型不像瀑布模型那样,需要分析活动结束后才开始设计活动,设计活动结束后才开始编码活动.该模型的各个阶段没有明显的界限,开发人员可以同步进行开发.其优点是可以提高软件项目开发效率,节省开发时间,适应于面向对象的软件开发过程.

缺点：
由于喷泉模型在各个开发阶段是重叠的,因此在开发过程中需要大量的开发人员,因此不利于项目的管理.此外这种模型要求严格管理文档,使得审核的难度加大,尤其是面对可能随时加入各种信息、需求与资料的情况。

### 原型模型

原型是预期系统的一个可执行版本，它反映了系统性质（如功能、计算结果等）的一个选定的子集。一个原型不必满足目标软件的所有约束，其目的是能快速、低成本地构建原型。

原型方法从软件工程师与客户的交流开始，其目的是定义软件的总体目标，标识需求。然后快速制订原型开发的计划，确定原型的目标和范围，采用快速设计的方式对其建模，并构建原型。

被开发的原型应交付给客户试用，并收集客户的反馈意见，这些反馈意见可在下一轮迭代中对原型进行改进。在前一个原型需要改进，或者需要扩展其范围的时候，进入下一轮原型的迭代开发。


类型：
- 探索型：其目的是要弄清目标系统的要求，确定所希望的特性，并探讨多种方案的可行性
- 实验型：其目的是验证方案或算法的合理性，它是在大规模开发和实现前，用于考核方案是否合适，规格说明是否可靠。
- 演化型：其目的是将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。

原型的使用策略：
- 废弃策略：主要用于探索型和实验型原型的开发。这些原型关注于目标系统的某些特性，而不是全部特性，开发这些原型时通常不考虑与探索或实验目的无关的功能、质量、结构等因素，这种原型通常被废丢，然后根据探索或实验的结果用良好的结构和设计思想重新设计目标系统。
- 追加策略：主要用于演化型原型的开发。这种原型通常是实现了目标系统中已明确定义的特性的一个子集，通过对它的不断修改和扩充，逐步追加新的要求，最后使其演化成最终的目标系统。

原型可作为单独的过程模型使用，它也常被作为一种方法或实现技术应用于其它的过程模型中

### 智能模型

智能模型拥有一组工具（如数据查询、报表生成、数据处理、屏幕定义、代码生成、高层图形功能及电子表格等），每个工具都能使开发人员在高层次上定义软件的某些特性，并把开发人员定义的这些软件自动地生成为源代码。

这种方法需要四代语言（4GL）的支持。4GL不同于三代语言，其主要特征是用户界面极端友好，即使没有受过训练的非专业程序员，也能用它编写程序；它是一种声明式、交互式和非过程性编程语言。4GL还具有高效的程序代码、智能缺省假设、完备的数据库和应用程序生成器。市场上流行的4GL（如Foxpro等）都不同程度地具有上述特征。但4GL主要限于事务信息系统的中、小型应用程序的开发。

## 软件开发方法

### 结构化开发方法

按照信息系统生命周期，应用结构化系统开发方法，把整个系统的开发过程分为若干阶段，然后一步一步她依次进行，前一阶段是后一阶段的工作依据；每个阶段又划分详细的工作步骤，顺序作业。每个阶段和主要步骤都有明确详尽的文档编制要求，各个阶段和各个步骤的向下转移都是通过建立各自的软件文档和对关键阶段、步骤进行审核和控制实现的。它是由结构化分析、结构化设计和结构化程序设计三部分有机组合而成的。它的基本思想：把一个复杂问题的求解过程分阶段进行，而且这种分解是自顶向下，逐层分解，使得每个阶段处理的问题都控制在人们容易理解和处理的范围内。

以数据流图，数据字典，结构化语言，判定表，判定树等图形表达为主要手段，强调开发方法的结构合理性和系统的结构合理性的软件分析方法。

特点：
- 遵循用户至上原则。
- 严格区分工作阶段，每个阶段有明确的任务和取得的成果。
- 强调系统开发过程的整体性和全局性。
- 系统开发过程工程化，文档资料标准化。

优点：
- 理论基础严密，它的指导思想是用户需求在系统建立之前就能被充分了解和理解。由此可见，结构化方法注重开发过程的整体性和全局性。
  
缺点：
- 开发周期长；文档、设计说明繁琐，工作效率低
- 要求在开发之初全面认识系统的信息需求，充分预料各种可能发生的变化，但这并不十分现实
- 若用户参与系统开发的积极性没有充分调动，造成系统交接过程不平稳，系统运行与维护管理难度加大

### 原型化开发方法

原型法的基本思想与结构化方法不同，原型法认为在很难一下子全面准确地提出用户需求的情况下，首先不要求一定要对系统做全面、详细的调查、分析，而是本着开发人员对用户需求的初步理解，先快速开发一个原型系统，然后通过反复修改来实现用户的最终系统需求。

是在投入大量的人力，物力之前，在限定的时间内，用最经济的方法开发出一个可实际运行的系统模型，用户在运行使用整个原型的基础上，通过对其评价，提出改进意见，对原型进行修改，统一使用，评价过程反复进行，使原型逐步完善，直到完全满足用户的需求为止。

适用范围：处理过程明确、简单系统；涉及面窄的小型系统

不适合：型、复杂系统，难以模拟；存在大量运算、逻辑性强的处理系统；管理基础工作不完善、处理过程不规范；大量批处理系统

特点：
- 实际可行。
- 具有最终系统的基本特征
- 构造方便、快速，造价低

原型法的特点在于原型法对用户的需求是动态响应、逐步纳入的，系统分析、设计与实现都是随着对一个工作模型的不断修改而同时完成的，相互之间并无明显界限，也没有明确分工。系统开发计划就是一个反复修改的过程。适于用户需求开始时定义不清的系统开发，开发方法更宜被用户接受；但如果用户配合不好，盲目修改，就会拖延开发过程。

### 面向对象开发方法

面向对象方法是一种运用对象、类、封装、继承、多态和消息等概念来构造、测试、重构软件的方法。随着应用系统日益复杂庞大和面向对象程序设计语言的日益成熟，面向对象的系统开发方法以其直观、方便的优点获得广泛应用。

是以认识论为基础，用对象来理解和分析问题空间，并设计和开发出由对象构成的软件系统（解空间）的方法。 由于问题空间和解空间都是由对象组成的，这样可以消除由于问题空间和求解空间结构上的不一致带来的问题。简言之，面向对象就是面向事情本身，面向对象的分析过程就是认识客观世界的过程。

面向对象方法从对象出发，发展出对象，类，消息，继承等概念。

面向对象方法的主要优点是：符合人们通常的思维方式；从分析到设计再到编码采用一致的模型表示具有高度连续性；软件重用性好。

### 敏捷软件的开发方法

是一种应对快速变化的需求的开发方法，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。

价值观：

- 人和（人与人的）交互 优先于过程和工具。
- 可以工作的软件 优先于求全责备的文档。
- 客户协作 优先于合同谈判。
- 随时应对变化 优先于循规蹈矩。

原则：

- 对我们而言，最重要的是通过尽早和不断交付有价值的软件满足客户需要。
- 我们欢迎需求的变化，即使在开发后期。敏捷过程能够驾驭变化，保持客户的竞争优势。
- 经常交付可以工作的软件，从几星期到几个月，时间尺度越短越好。
- 业务人员和开发者应该在整个项目过程中始终朝夕在一起工作。
- 围绕斗志高昂的人进行软件开发，给开发者提供适宜的环境，满足他们的需要，并相信他们能够完成任务。
- 在开发小组中最有效率也最有效果的信息传达方式是面对面的交谈。
- 可以工作的软件是进度的主要度量标准。
- 敏捷过程提倡可持续开发。出资人、开发人员和用户应该总是维持不变的节奏。
- 对卓越技术与良好设计的不断追求将有助于提高敏捷性。
- 简单——尽可能减少工作量的艺术至关重要。
- 最好的架构、需求和设计都源自自我组织的团队。
- 每隔一定时间，团队都要总结如何更有效率，然后相应地调整自己的行为。

## 需求分析

## 敏捷开发

### 敏捷开发理解

一种软件开发的流程，它会指导我们用规定的环节去一步一步完成项目的开发；而这种开发方式的主要驱动核心是人；它采用的是迭代式开发。

敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。每次迭代都必须依次完成以下五个步骤：
1. 需求分析
2. 设计
3. 编码
4. 测试
5. 部署和评估

好处：
- 早期交付，从而大大降低成本。
- 及时了解市场需求，降低产品不适用的风险。

价值观：
- 程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。
- 软件能够运行，优于详尽的文档。
- 跟客户的密切协作，优于合同和谈判。
- 能够响应变化，优于遵循计划。
  
12条原则：
1. 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。
2. 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。
3. 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。
4. 业务人员和开发人员必须相互合作，项目中的每一天都不例外。
5. 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。
6. 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。
7. 可工作的软件是进度的首要度量标准。
8. 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。
9. 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。
10. 以简洁为本，它是极力减少不必要工作量的艺术。
11. 最好的架构、需求和设计出自自组织团队。
12. 团队定期地反思如何能提高成效，并依此调整自身的举止表现。

### scrum敏捷开发

Scrum作为敏捷的落地方法之一，用不断迭代的框架方法来管理复杂产品的开发，成为当前最火的敏捷管理方法。项目成员会以1-2周的迭代周期（我们称之为sprint）不断产出新版本软件，而在每次迭代完成后，项目成员和利益方再次碰头确认下次迭代的方向和目标。Scrum有一套其独特且固定管理方式，从角色、工件和不同形式的会议三个维度出发，来保证执行过程更高效。例如在每次sprints开始前会确立整个过程：迭代规划、每日站会、迭代演示和回顾。并在sprint期间用可视化工件（看板kanban或燃尽图burndown）确认进度和收集客户反馈。

#### 工作原理：

在Scrum中，产品经理和项目团队紧密协作，一起定义目标、梳理产品需求清单。清单中通常会包含产品特性、修复bug、非必要功能需求以及其他要在交付时完成的工作。
有了产品清单，产品经理就会开始确定需求优先级，研发团队通常会在接下来30天左右的迭代中产出“潜在可交付版本”。当研发团队制定了迭代清单后，除了团队成员外，任何人都不能再加入需求。当一轮迭代完成后，全员再次分析需求清单、划分需求优先级，然后进入下一轮迭代。

#### 三大角色

- 产品负责人（Product Owner）： 主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。
- 流程管理员（Scrum Master）：主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。
- 开发团队（Scrum Team）： 主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。

#### 物件
- Product Backlog： 按优先顺序排列的一个产品需求列表
- Sprint Backlog： 待办事项
- 燃尽图：对需要完成的工作的一种可视化表示

#### 过程

1. 我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；
2. Scrum Team根据Product Backlog列表，做工作量的预估和安排；
3. 有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；
4. Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）；
5. 在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；
6. 做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；
7. 当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；
8. 最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；
   
#### Scrum和XP的区别

-  迭代周期不同：
  XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周。
- 在迭代中，是否允许修改需求：
  XP在一个迭代中，如果一个User Story(用户素材, 也就是一个需求)还没有实现， 则可以考虑用另外的需求将其替换， 替换的原则是需求实现的时间量是相等的。 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来，并有Scrum Master严格把关，不允许开发团队收到干扰。
- 在迭代中，User Story是否严格按照优先级别来实现：
  XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活， 可以不按照优先级别来做，Scrum这样处理的理由是： 如果优先问题的解决者，由于其它事情耽搁，不能认领任务，那么整个进度就耽误了。 另外一个原因是，如果按优先级排序的User Story #6和#10，虽然#6优先级高，但是如果#6的实现要依赖于#10，则不得不优先做#10。
- 软件的实施过程中，是否采用严格的工程方法，保证进度或者质量：
  Scrum没有对软件的整个实施过程开出养个工程实践的处方。要求开发者自觉保证，但XP对整个流程方法定义非常严格，规定需要采用TDD, 自动测试， 结对编程，简单设计，重构等约束团队的行为。因此，原作者认为， 这点上，XP的做法值得认同的，但是却把敏捷带入了一个让人困惑的矛盾, 因为xp的理念，结合敏捷模式，表达给团队的信息是“你是一个完全自我管理的组织， 但你必须要实现TDD, 结对编程, ...等等”。

#### 结对编程

结对编程是一种敏捷软件开发的方法，两个程序员在一个计算机上共同工作。一个人输入代码，而另一个人审查他输入的每一行代码。输入代码的人称作驾驶员，审查代码的人称作观察员（或导航员）。两个程序员经常互换角色。
在结对编程中，观察员同时考虑工作的战略性方向，提出改进的意见，或将来可能出现的问题以便处理。这样使得驾驶者可以集中全部注意力在完成当前任务的“战术”方面。观察员当作安全网和指南。结对编程对开发程序有很多好处。比如增加纪律性，写出更好的代码等。

#### TDD测试驱动开发

TDD 有广义和狭义之分，常说的是狭义的 TDD，也就是 UTDD（Unit Test Driven Development）单元测试驱动开发。
TDD 是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD 是 XP（Extreme Programming）的核心实践。

编码方式：
1. 先分解任务，分离关注点
2. 列 Example，用实例化需求，澄清需求细节
3. 写测试，只关注需求，程序的输入输出，不关心中间过程
4. 写实现，不考虑别的需求，用最简单的方式满足当前这个小需求即可
5. 重构，用手法消除代码里的坏味道
6. 写完，手动测试一下，基本没什么问题，有问题补个用例，修复
7. 转测试，小问题，补用例，修复
8. 代码整洁且用例齐全，信心满满地提交

三条规则：
- 除非是为了使一个失败的 unit test 通过，否则不允许编写任何产品代码
- 在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）
- 只允许编写刚好能够使一个失败的 unit test 通过的产品代码


